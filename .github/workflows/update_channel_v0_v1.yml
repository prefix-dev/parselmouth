name: Update Channel Mappings (v0 + v1)

on:
  workflow_call:
    inputs:
      channel:
        description: 'The conda channel to update (conda-forge, pytorch, bioconda, tango-controls)'
        required: true
        type: string
      cron_schedule:
        description: 'Cron schedule for this channel'
        required: false
        type: string
        default: '*/30 * * * *'
      use_legacy_mapping:
        description: 'Whether to use legacy mapping (grayskull mapping)'
        required: false
        type: boolean
        default: false
      needs_anaconda_token:
        description: 'Whether this channel requires ANACONDA_TOKEN'
        required: false
        type: boolean
        default: false
      force_v1_generation:
        description: 'Force v1 mappings generation even if no new packages'
        required: false
        type: boolean
        default: false
    secrets:
      R2_PREFIX_ACCOUNT_ID:
        required: true
      R2_PREFIX_ACCESS_KEY_ID:
        required: true
      R2_PREFIX_SECRET_ACCESS_KEY:
        required: true
      R2_PREFIX_BUCKET:
        required: true
      GH_TOKEN:
        required: true
      ANACONDA_TOKEN:
        required: false

concurrency:
  group: update-${{ inputs.channel }}

jobs:
  generate_hash_letters:
    runs-on: ubuntu-latest
    outputs:
      string_list: ${{ steps.generate.outputs.string_list }}
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5
      - uses: prefix-dev/setup-pixi@v0.9.3

      - name: Generate combination of missing subdirs and letters
        id: generate
        run: |
          # Run your script here to produce a list of missing subdirs and letters
          # example: linux-64@p linux-64@d
          message=$(pixi run parselmouth updater-producer --channel ${{ inputs.channel }})
          echo $message
          echo "string_list=$message" >> $GITHUB_OUTPUT
          if [ "$message" = "[]" ]; then
            echo "No new packages found, workflow will skip processing jobs"
          fi
        env:
          R2_PREFIX_ACCOUNT_ID: ${{ secrets.R2_PREFIX_ACCOUNT_ID }}
          R2_PREFIX_ACCESS_KEY_ID: ${{ secrets.R2_PREFIX_ACCESS_KEY_ID }}
          R2_PREFIX_SECRET_ACCESS_KEY: ${{ secrets.R2_PREFIX_SECRET_ACCESS_KEY }}
          R2_PREFIX_BUCKET: ${{ secrets.R2_PREFIX_BUCKET }}
          ANACONDA_TOKEN: ${{ inputs.needs_anaconda_token && secrets.ANACONDA_TOKEN || '' }}

      - name: Upload requested index.json
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: index
          path: output_index

  updater_of_records:
    runs-on: ubuntu-latest
    needs: generate_hash_letters
    if: needs.generate_hash_letters.outputs.string_list != '[]'
    strategy:
      matrix:
        subdirs: ${{fromJson(needs.generate_hash_letters.outputs.string_list)}}

    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5
      - uses: prefix-dev/setup-pixi@v0.9.3

      - name: Get partial index artifacts
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5
        with:
          name: index
          path: output_index

      - name: Get artifact info for subdir@letter and save into partial index
        run: pixi run parselmouth updater ${{ matrix.subdirs }} --channel ${{ inputs.channel }} --upload
        env:
          R2_PREFIX_ACCOUNT_ID: ${{ secrets.R2_PREFIX_ACCOUNT_ID }}
          R2_PREFIX_ACCESS_KEY_ID: ${{ secrets.R2_PREFIX_ACCESS_KEY_ID }}
          R2_PREFIX_SECRET_ACCESS_KEY: ${{ secrets.R2_PREFIX_SECRET_ACCESS_KEY }}
          R2_PREFIX_BUCKET: ${{ secrets.R2_PREFIX_BUCKET }}
          ANACONDA_TOKEN: ${{ inputs.needs_anaconda_token && secrets.ANACONDA_TOKEN || '' }}

      - name: Upload partial index
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: partial_index_${{ matrix.subdirs }}
          path: output

  updater_of_index:
    runs-on: ubuntu-latest
    needs: updater_of_records
    if: needs.updater_of_records.result == 'success'
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5
      - uses: prefix-dev/setup-pixi@v0.9.3

      - name: Get partial index artifacts
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5
        with:
          merge-multiple: true
          path: output

      - name: Combine all partial index and save into S3 index
        run: pixi run parselmouth updater-merger --upload --channel ${{ inputs.channel }}
        env:
          R2_PREFIX_ACCOUNT_ID: ${{ secrets.R2_PREFIX_ACCOUNT_ID }}
          R2_PREFIX_ACCESS_KEY_ID: ${{ secrets.R2_PREFIX_ACCESS_KEY_ID }}
          R2_PREFIX_SECRET_ACCESS_KEY: ${{ secrets.R2_PREFIX_SECRET_ACCESS_KEY }}
          R2_PREFIX_BUCKET: ${{ secrets.R2_PREFIX_BUCKET }}
          ANACONDA_TOKEN: ${{ inputs.needs_anaconda_token && secrets.ANACONDA_TOKEN || '' }}

  # ===== Generate v1 Mappings (Relations Table + PyPI Lookups) =====
  update_v1_mappings:
    runs-on: ubuntu-latest
    needs: [generate_hash_letters, updater_of_index]
    if: |
      always() &&
      (inputs.force_v1_generation == true || needs.updater_of_index.result == 'success')
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5
      - uses: prefix-dev/setup-pixi@v0.9.3

      - name: Generate and upload v1 mappings (relations table + PyPI lookups)
        run: |
          echo "Generating v1 mappings from updated index..."
          pixi run parselmouth update-v1-mappings --upload --channel ${{ inputs.channel }}
        env:
          R2_PREFIX_ACCOUNT_ID: ${{ secrets.R2_PREFIX_ACCOUNT_ID }}
          R2_PREFIX_ACCESS_KEY_ID: ${{ secrets.R2_PREFIX_ACCESS_KEY_ID }}
          R2_PREFIX_SECRET_ACCESS_KEY: ${{ secrets.R2_PREFIX_SECRET_ACCESS_KEY }}
          R2_PREFIX_BUCKET: ${{ secrets.R2_PREFIX_BUCKET }}
          ANACONDA_TOKEN: ${{ inputs.needs_anaconda_token && secrets.ANACONDA_TOKEN || '' }}

  # ================================================

  update_file:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # To push on main branch
    needs: [updater_of_index, update_v1_mappings]  # Wait for BOTH v0 and v1
    if: |
      always() &&
      (needs.updater_of_index.result == 'success' || needs.updater_of_index.result == 'skipped') &&
      (needs.update_v1_mappings.result == 'success' || needs.update_v1_mappings.result == 'skipped')
    steps:
      - name: Checkout code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5
      - uses: prefix-dev/setup-pixi@v0.9.3

      - name: Update legacy mapping (if needed)
        if: ${{ inputs.use_legacy_mapping }}
        run: pixi run parselmouth update-mapping-legacy
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
          R2_PREFIX_ACCOUNT_ID: ${{ secrets.R2_PREFIX_ACCOUNT_ID }}
          R2_PREFIX_ACCESS_KEY_ID: ${{ secrets.R2_PREFIX_ACCESS_KEY_ID }}
          R2_PREFIX_SECRET_ACCESS_KEY: ${{ secrets.R2_PREFIX_SECRET_ACCESS_KEY }}
          R2_PREFIX_BUCKET: ${{ secrets.R2_PREFIX_BUCKET }}
          ANACONDA_TOKEN: ${{ inputs.needs_anaconda_token && secrets.ANACONDA_TOKEN || '' }}

      - name: Update compressed mapping
        run: pixi run parselmouth update-mapping --channel ${{ inputs.channel }}
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
          R2_PREFIX_ACCOUNT_ID: ${{ secrets.R2_PREFIX_ACCOUNT_ID }}
          R2_PREFIX_ACCESS_KEY_ID: ${{ secrets.R2_PREFIX_ACCESS_KEY_ID }}
          R2_PREFIX_SECRET_ACCESS_KEY: ${{ secrets.R2_PREFIX_SECRET_ACCESS_KEY }}
          R2_PREFIX_BUCKET: ${{ secrets.R2_PREFIX_BUCKET }}
          ANACONDA_TOKEN: ${{ inputs.needs_anaconda_token && secrets.ANACONDA_TOKEN || '' }}

      - name: Commit and push changes
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git pull
          if [ "${{ inputs.use_legacy_mapping }}" = "true" ]; then
            git add files/mapping_as_grayskull.json
            git add files/compressed_mapping.json
          fi
          git add files/v0/${{ inputs.channel }}
          git commit -m "Update ${{ inputs.channel }} mappings (v0 + v1) via GitHub Action" || true
          git push
